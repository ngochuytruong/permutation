{"kernelspec":{"display_name":"Python 2 (SageMath)","language":"python","name":"python2"},"language_info":{"codemirror_mode":{"name":"ipython","version":2},"file_extension":".py","mimetype":"text/x-python","name":"python","nbconvert_exporter":"python","pygments_lexer":"ipython2","version":"2.7.10"}}
{"cell_type":"markdown","metadata":{"collapsed":false},"source":"# Permutation Modulus\n\nWe want to compute the *permutation modulus* of a random permutation. Given a permutation $\\omega \\in S_N$, let $\\Gamma$ be the family of all maximal increasing subsequences (**MISS**).  A maximal increasing subsequence is a sequence $$\\omega(i_1)<\\cdots<\\omega(i_k)$$ for a choice of integers $1\\le i_1<\\cdots< i_k\\le N$, that cannot be extended. We denote a **MISS** by $\\gamma$ and set $\\mathcal{N}(\\gamma,j)=1$ if $j=\\omega(i_m)$ for some $m$, and $=0$ otherwise. Given a density $\\rho\\in \\mathbb{R}_+^N$:\n$$\n\\ell_\\rho(\\gamma):=\\sum_{j=1}^N  \\mathcal{N}(\\gamma,j)\\rho(j)\n$$\nAlso, $\\rho$ is admissible for $\\Gamma$ if $\\ell_\\rho(\\gamma)\\geq 1$ for all $\\gamma\\in \\Gamma$, and  write $\\rho\\in{\\rm Adm}(\\Gamma)$. Then, \n$$\n{\\rm Mod}(\\Gamma) = \\inf_{\\rho\\in{\\rm Adm}(\\Gamma)} \\sum_{j=1}^N \\rho(j)^2\n$$ \nTo compute modulus with our modulus code we need an algorithm that, given a density $\\rho$, finds the $\\rho$-lightest maximal increasing subsequence in $\\omega$. In the paper \\cite{atallah-manacher-urrutia:dam1988}  there is an algorithm that is $O(N\\log^2 N)$.\n\n## Exercise 1: Implement our modulus code using the Atallah-etal algorithm \n\n  Given a permutation $\\omega$ one builds a graph $G(\\omega)$ with vertex set $\\{1,\\dots,N\\}$ and edges $\\{i,j\\}$ whenever $i<j$ and $\\omega^{-1}(i)>\\omega^{-1}(j)$. Also a subset $S\\subset V$ is a {\\it dominating set} if every $x\\in V$ is adjacent to $S$, and $S$ is {\\it independent} if no to nodes in $S$ are adjacent. One could then consider the family $\\Gamma$ of all dominating independent sets (**DIS**) in $V$, and compute the (vertex)-modulus of $\\Gamma$. It seems that computing modulus for **DIS** is equivalent to computing modulus for **MISS**.\n"}
{"cell_type":"markdown","metadata":{},"source":"# Example\n\nConsider the permutation of $1,\\dots,20$:\n\n$$\n\\pi = 7\\ 3\\ 1\\ 17\\ 10\\ 18\\ 9\\ 20\\ 6\\ 12\\ 16\\ 13\\ 2\\ 8\\ 19\\ 4\\ 15\\ 11\\ 14\\ 5\n$$\n\nLet's graph it as scatter plot."}
{"cell_type":"code","execution_count":1,"metadata":{"collapsed":true,"trusted":false},"outputs":[],"source":"######################################################################\n# import necessary libraries\n\n%matplotlib inline\nimport matplotlib.pyplot as plt\nimport networkx as nx\nimport numpy as np\nimport cvxopt as cvx\nfrom cvxopt.solvers import qp\nfrom fractions import Fraction\nimport math"}
{"cell_type":"code","execution_count":14,"metadata":{"collapsed":false,"trusted":false},"outputs":[{"data":{"image/png":"smc-blob::3d895ab8-7502-4c6f-adf1-1ab09f9ed800","text/plain":"<matplotlib.figure.Figure at 0x7ff477739f10>"},"metadata":{},"output_type":"display_data"}],"source":"pi =  [7, 3, 1, 17, 10, 18, 9, 20, 6, 12, 16, 13, 2, 8, 19, 4, 15, 11, 14, 5]\n\nx = range(1,21)\n\n\n# initialize figure\nfig, ax = plt.subplots(figsize=(8, 8))\n    \nplt.scatter(x,pi)\n\n# Set the ticks to be at the edges of the bins.\nax.set_xticks(range(0,21))\nax.set_yticks(range(0,21))\nplt.grid(True)\n\n\nNone"}
{"cell_type":"code","execution_count":4,"metadata":{"collapsed":false,"trusted":false},"outputs":[{"data":{"text/plain":"20"},"execution_count":4,"metadata":{},"output_type":"execute_result"}],"source":"len(pi)"}
{"cell_type":"markdown","metadata":{},"source":"Here's an example of **MISS** (in fact this a longest increasing subsequence):\n$$\n1\\ 6\\ 8\\ 11\\ 14\n$$\ncorresponding to the indeces $3<9<14<18<19$."}
{"cell_type":"code","execution_count":13,"metadata":{"collapsed":false,"trusted":false},"outputs":[{"data":{"image/png":"smc-blob::6a14ecba-148e-4772-afb9-c2fe2c09dbf9","text/plain":"<matplotlib.figure.Figure at 0x7ff4755e0490>"},"metadata":{},"output_type":"display_data"}],"source":"pi =  [7, 3, 1, 17, 10, 18, 9, 20, 6, 12, 16, 13, 2, 8, 19, 4, 15, 11, 14, 5]\nx = range(1,21)\n\nga = [1,6,8,11,14]\nI = [3,9,14,18,19]\n\n# initialize figure\nfig, ax = plt.subplots(figsize=(8, 8))\n    \nplt.scatter(x,pi)\nplt.plot(I,ga)\n\n# Set the ticks to be at the edges of the bins.\nax.set_xticks(range(0,21))\nax.set_yticks(range(0,21))\nplt.grid(True)\n\nNone"}
{"cell_type":"markdown","metadata":{},"source":"## Exercise 2: write code for computing all MISS for a given permutation. Also plot the resulting graph of up/right paths, as above.\n\nNote that this is only useful for small permutations. However, for larger ones the modulus computation does not need to know all of the **MISS** in advance. "}
{"cell_type":"markdown","metadata":{},"source":"Note that the resulting graph will be a subgraph of the graph obtained by saying that two points $(i_1,\\pi(i_1))$ and $(i_2,\\pi(i_2))$ are connected iff $(i_2-i_1)(\\pi(i_2)-\\pi(i_1))>0$, because the latter will include also increasing subsequences that are not maximal."}
{"cell_type":"code","execution_count":null,"metadata":{"collapsed":true,"trusted":false},"outputs":[],"source":""}
{"cell_type":"markdown","metadata":{},"source":"## Exercise 3: Do the same for maximal decreasing sequences (these should form a sort of blocker dual)"}
{"cell_type":"markdown","metadata":{},"source":"# Young Tableaux\n\nNext we recall the theory of Young tableaux.\n\n  * Given a integer $N$ a *partition* of $N$ is $\\lambda=(\\lambda_1,\\dots,\\lambda_r)$ so that\n     * $\\lambda_1\\ge \\cdots\\ge\\lambda_r> 0$\n     * $|\\lambda|:=\\sum_{j=1}^r \\lambda_j=N$\n     \n  * We say $r=r(\\lambda)$ is the *length* of the partition and write $\\lambda\\vdash N$.\n    \n  * A *Young diagram* is a way to represent a partition. For instance $(5,2,2)\\vdash 9$ is drawn as follows:\n  "}
{"cell_type":"code","execution_count":6,"metadata":{"collapsed":false,"trusted":false},"outputs":[{"name":"stdout","output_type":"stream","text":"a b c d e\nf g\nh i\n"}],"source":"yd = [['a', 'b', 'c','d', 'e'],['f','g'],['h','i']]\nfor item in yd:\n    print item[0], ' '.join(map(str, item[1:]))"}
{"cell_type":"markdown","metadata":{},"source":"  * A *Young tableau* is a Young diagram filled with the numbers $1,\\dots,N$."}
{"cell_type":"code","execution_count":5,"metadata":{"collapsed":false,"trusted":false},"outputs":[{"name":"stdout","output_type":"stream","text":"7 8 4 5 6\n1 2\n3 9\n"}],"source":"yt = [[7, 8, 4, 5, 6],[1,2],[3,9]]\nfor item in yt:\n    print item[0], ' '.join(map(str, item[1:]))"}
{"cell_type":"markdown","metadata":{},"source":"  * A *Standard Young tableau* (SYT) is a Young tableau so that entries increase in both rows and columns."}
{"cell_type":"code","execution_count":4,"metadata":{"collapsed":false,"trusted":false},"outputs":[{"name":"stdout","output_type":"stream","text":"1 3 5 7 9\n2 4\n6 8\n"}],"source":"syt = [[1, 3, 5, 7, 9],[2,4],[6,8]]\nfor item in syt:\n    print item[0], ' '.join(map(str, item[1:]))"}
{"cell_type":"markdown","metadata":{},"source":"  * The Young diagram underlying a SYT is called the *shape* and we write ${\\rm sh}(T)$.\n  * The set of all permutations  $S_N$ is in one-to-one correspondence with pairs $(P,Q)$ of SYTs such that\n     * ${\\rm sh}(P)={\\rm sh}(Q)$.\n     * ${\\rm sh}(P)\\vdash N$.\n     \n## Exercise 4: Implement the algorithm that takes a permutation and gives the corresponding pair of SYT, as well as the inverse operation.\n\n  * The forward direction is based on an operation called *row insertion*.\n    * Suppose $x\\not \\in P$. Let $R$ be the first row of $P$.\n    * While $x<\\max R$:\n      * Let $y=\\min\\{z\\in R: z>x\\}$\n      * Replace $y$ by $x$\n      * Set $x:=y$ and $R$ equal to the next row.\n    * Place $x$ at the end of row $R$ and stop."}
{"cell_type":"code","execution_count":null,"metadata":{"collapsed":true,"trusted":false},"outputs":[],"source":""}